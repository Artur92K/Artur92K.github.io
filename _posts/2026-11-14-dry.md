---
title: "DR (Don't repeat) myths about DRY (Don't Repeat Yourself)"
date: 2026-11-14 15:00:00 +/-0200
description: An insightful article about testing Kotlin suspend functions in JUnit 6 and the essential role of the @TestInstance annotation in managing the test lifecycle.
categories: [Software, Architecture ]
tags: [ jdk, architecture, design-patterns, best-practices ] 
image: /assets/images/junit6-suspend-img.png
---

# Introduction

JUnit 6 was officially released on September 30, 2025, marking the next evolution of the popular Java testing framework.
Building on the robust foundation of JUnit 5, this release brings several important improvements
and some breaking changes aimed at modern JVM development, including enhanced Kotlin support.

## Introduction: What is the DRY principle?
## Why DRY matters for engineering teams
## Examples of breaking DRY in Java projects
## DRY in the context of DDD — how not to duplicate domain knowledge
## Microservices and DRY: whether and how to share code
## Modular monolith and duplication control
## Internal Maven libraries: when to build/share?
## Overusing DRY pitfalls: when is repetition better?
## Refactor examples and unit tests in Java
## Conclusion, recommendations, and further reading

## Table of Contents 2 — Architecture and DRY: strategy and trade-offs
## Introduction to DRY — origins and definition
## DRY vs. other principles (SRP, KISS, YAGNI)
## DDD: sharing aggregates with respect for DRY
## Microservices: DRY within a service vs. across services
## Modular monoliths: module isolation and DRY boundaries
## Code organization: shared Maven libs, versioning, and testing
## Real-world refactoring examples in Java
## In-house libraries: pros and cons of sharing in large systems
## When and why to allow code duplication?
## Takeaways: balancing DRY, readability, and system maintainability
